/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export interface Config {
  require?: string[];
  /**
   * Defines the list of your external data sources for your API mesh
   */
  sources: Source[];
  /**
   * Transform to apply to the unified mesh schema
   */
  transforms?: Transform[];
  /**
   * Additional resolvers, or resolvers overrides you wish to add to the schema mesh
   */
  additionalResolvers?: string[];
  /**
   * Backend cache (Any of: InMemoryLRU, Redis)
   */
  cache?: InMemoryLRU | Redis;
}
export interface Source {
  /**
   * The name you wish to set to your remote API, this will be used for building the GraphQL context
   */
  name: string;
  /**
   * Custom JSON object to add to the GraphQL context, use this to inject custom
   * fields and later use it in your custom resolver. This object will be located
   * in the context, under an object named as the API
   */
  context?: {
    [k: string]: any;
  };
  handler: Handler;
  /**
   * List of transforms to apply to the current API source, before unifying it with the rest of the sources
   */
  transforms?: Transform[];
}
/**
 * Point to the handler you wish to use, it can either be a predefined handler, or a custom
 */
export interface Handler {
  graphql?: GraphQLHandler;
  grpc?: GrpcHandler;
  jsonSchema?: JsonSchemaHandler;
  mongoose?: MongooseHandler;
  openapi?: OpenapiHandler;
  postgraphile?: PostGraphileHandler;
  soap?: SoapHandler;
}
/**
 * Handler for remote/local/third-party GraphQL schema
 */
export interface GraphQLHandler {
  /**
   * JSON object representing the Headers to add to the runtime of the API calls
   */
  headers?: {
    [k: string]: any;
  };
  /**
   * A url to your remote GraphQL endpoint
   */
  endpoint: string;
}
/**
 * Handler for gRPC and Protobuf schemas
 */
export interface GrpcHandler {
  endpoint: string;
  protoFilePath: string;
  serviceName: string;
  packageName: string;
}
/**
 * Handler for JSON Schema specification. Source could be a local json file, or a url to it.
 */
export interface JsonSchemaHandler {
  baseUrl: string;
  typeReferences?: JsonSchemaTypeReference[];
  operationHeaders?: {
    [k: string]: any;
  };
  schemaHeaders?: {
    [k: string]: any;
  };
  operations: JsonSchemaOperation[];
}
export interface JsonSchemaTypeReference {
  reference: string;
  sharedType: string;
  inputType: string;
  outputType: string;
}
export interface JsonSchemaOperation {
  field: string;
  path: string;
  description?: string;
  /**
   * Allowed values: Query, Mutation
   */
  type: "Query" | "Mutation";
  /**
   * Allowed values: GET, DELETE, POST, PUT
   */
  method: "GET" | "DELETE" | "POST" | "PUT";
  requestSchema: string;
  responseSchema: string;
  headers?: {
    [k: string]: any;
  };
}
export interface MongooseHandler {
  connectionString?: string;
  models?: MongooseModel[];
  discriminators?: MongooseModel[];
}
export interface MongooseModel {
  name: string;
  path: string;
  options?: ComposeWithMongooseOpts;
}
export interface ComposeWithMongooseOpts {
  name?: string;
  description?: string;
  fields?: ComposeWithMongooseFieldsOpts;
  inputType?: ComposeWithMongooseOpts;
  resolvers?: TypeConverterResolversOpts;
}
export interface ComposeWithMongooseFieldsOpts {
  only?: string[];
  remove?: string[];
  required?: string[];
}
export interface TypeConverterResolversOpts {
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  findById?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  findByIds?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  findOne?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  findMany?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  updateById?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  updateOne?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  updateMany?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  removeById?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  removeOne?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  removeMany?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  createOne?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  createMany?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, ComposeWithMongooseResolverOpts
   */
  count?: boolean | ComposeWithMongooseResolverOpts;
  /**
   * Any of: Boolean, JSON
   */
  connection?:
    | boolean
    | {
        [k: string]: any;
      };
  /**
   * Any of: Boolean, PaginationResolverOpts
   */
  pagination?: boolean | PaginationResolverOpts;
}
export interface ComposeWithMongooseResolverOpts {
  filter?: FilterHelperArgsOpts;
  sort?: SortHelperArgsOpts;
  limit?: LimitHelperArgsOpts;
  record?: RecordHelperArgsOpts;
  skip?: boolean;
}
export interface FilterHelperArgsOpts {
  filterTypeName?: string;
  isRequired?: boolean;
  onlyIndexed?: boolean;
  requiredFields?: string[];
  /**
   * Any of: Boolean, JSON
   */
  operators?:
    | boolean
    | {
        [k: string]: any;
      };
  removeFields?: string[];
}
export interface SortHelperArgsOpts {
  sortTypeName?: string;
}
export interface LimitHelperArgsOpts {
  defaultValue?: number;
}
export interface RecordHelperArgsOpts {
  recordTypeName?: string;
  isRequired?: boolean;
  removeFields?: string[];
  requiredFields?: string[];
}
export interface PaginationResolverOpts {
  perPage?: number;
}
/**
 * Handler for Swagger / OpenAPI 2/3 specification. Source could be a local json/swagger file, or a url to it.
 */
export interface OpenapiHandler {
  /**
   * A pointer to your API source - could be a local file, remote file or url endpoint
   */
  source: string;
  /**
   * JSON object representing the Headers to add to the runtime of the API calls
   */
  headers?: {
    [k: string]: any;
  };
}
/**
 * Handler for Postgres database, based on `postgraphile`
 */
export interface PostGraphileHandler {
  /**
   * A connection string to your Postgres database
   */
  connectionString: string;
  /**
   * An array of strings which specifies the PostgreSQL schemas that PostGraphile
   * will use to create a GraphQL schema. The default schema is the public schema.
   */
  schemaName?: string[];
  pool?: PostGraphilePool;
}
/**
 * Connection Pool settings
 */
export interface PostGraphilePool {
  user?: string;
  password?: string;
  database?: string;
  host?: string;
  port?: number;
  connectionString?: string;
}
/**
 * Handler for SOAP
 */
export interface SoapHandler {
  /**
   * A url to your WSDL
   */
  wsdl: string;
  config?: {
    [k: string]: any;
  };
}
export interface Transform {
  /**
   * GraphQL SDL and apply to the schema
   */
  extend?: string;
  prefix?: PrefixTransformConfig;
  /**
   * Transformer to apply rename of a GraphQL type
   */
  rename?: RenameTransformObject[];
}
/**
 * Prefix transform
 */
export interface PrefixTransformConfig {
  /**
   * The prefix to apply to the schema types. By default it's the API name.
   */
  value?: string;
  /**
   * List of ignored types
   */
  ignore?: string[];
  /**
   * Changes root types and changes the field names
   */
  includeRootOperations?: boolean;
}
export interface RenameTransformObject {
  /**
   * The GraphQL type to rename
   */
  from: string;
  /**
   * The new name
   */
  to: string;
}
export interface InMemoryLRU {
  name: string;
  config?: InMemoryLRUConfig;
}
export interface InMemoryLRUConfig {
  max?: number;
}
export interface Redis {
  name: string;
  config?: RedisConfig;
}
export interface RedisConfig {
  host?: string;
  port?: number;
  password?: string;
}
